<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/genomics/v1/reads.proto

namespace Google\Genomics\V1;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * <pre>
 * The stream reads request.
 * </pre>
 *
 * Protobuf type <code>google.genomics.v1.StreamReadsRequest</code>
 */
class StreamReadsRequest extends \Google\Protobuf\Internal\Message
{
    /**
     * <pre>
     * The Google Cloud project ID which will be billed
     * for this access. The caller must have WRITE access to this project.
     * Required.
     * </pre>
     *
     * <code>string project_id = 1;</code>
     */
    private $project_id = '';
    /**
     * <pre>
     * The ID of the read group set from which to stream reads.
     * </pre>
     *
     * <code>string read_group_set_id = 2;</code>
     */
    private $read_group_set_id = '';
    /**
     * <pre>
     * The reference sequence name, for example `chr1`,
     * `1`, or `chrX`. If set to *, only unmapped reads are
     * returned.
     * </pre>
     *
     * <code>string reference_name = 3;</code>
     */
    private $reference_name = '';
    /**
     * <pre>
     * The start position of the range on the reference, 0-based inclusive. If
     * specified, `referenceName` must also be specified.
     * </pre>
     *
     * <code>int64 start = 4;</code>
     */
    private $start = 0;
    /**
     * <pre>
     * The end position of the range on the reference, 0-based exclusive. If
     * specified, `referenceName` must also be specified.
     * </pre>
     *
     * <code>int64 end = 5;</code>
     */
    private $end = 0;
    /**
     * <pre>
     * Restricts results to a shard containing approximately `1/totalShards`
     * of the normal response payload for this query. Results from a sharded
     * request are disjoint from those returned by all queries which differ only
     * in their shard parameter. A shard may yield 0 results; this is especially
     * likely for large values of `totalShards`.
     * Valid values are `[0, totalShards)`.
     * </pre>
     *
     * <code>int32 shard = 6;</code>
     */
    private $shard = 0;
    /**
     * <pre>
     * Specifying `totalShards` causes a disjoint subset of the normal response
     * payload to be returned for each query with a unique `shard` parameter
     * specified. A best effort is made to yield equally sized shards. Sharding
     * can be used to distribute processing amongst workers, where each worker is
     * assigned a unique `shard` number and all workers specify the same
     * `totalShards` number. The union of reads returned for all sharded queries
     * `[0, totalShards)` is equal to those returned by a single unsharded query.
     * Queries for different values of `totalShards` with common divisors will
     * share shard boundaries. For example, streaming `shard` 2 of 5
     * `totalShards` yields the same results as streaming `shard`s 4 and 5 of 10
     * `totalShards`. This property can be leveraged for adaptive retries.
     * </pre>
     *
     * <code>int32 total_shards = 7;</code>
     */
    private $total_shards = 0;

    public function __construct() {
        \GPBMetadata\Google\Genomics\V1\Reads::initOnce();
        parent::__construct();
    }

    /**
     * <pre>
     * The Google Cloud project ID which will be billed
     * for this access. The caller must have WRITE access to this project.
     * Required.
     * </pre>
     *
     * <code>string project_id = 1;</code>
     */
    public function getProjectId()
    {
        return $this->project_id;
    }

    /**
     * <pre>
     * The Google Cloud project ID which will be billed
     * for this access. The caller must have WRITE access to this project.
     * Required.
     * </pre>
     *
     * <code>string project_id = 1;</code>
     */
    public function setProjectId($var)
    {
        GPBUtil::checkString($var, True);
        $this->project_id = $var;
    }

    /**
     * <pre>
     * The ID of the read group set from which to stream reads.
     * </pre>
     *
     * <code>string read_group_set_id = 2;</code>
     */
    public function getReadGroupSetId()
    {
        return $this->read_group_set_id;
    }

    /**
     * <pre>
     * The ID of the read group set from which to stream reads.
     * </pre>
     *
     * <code>string read_group_set_id = 2;</code>
     */
    public function setReadGroupSetId($var)
    {
        GPBUtil::checkString($var, True);
        $this->read_group_set_id = $var;
    }

    /**
     * <pre>
     * The reference sequence name, for example `chr1`,
     * `1`, or `chrX`. If set to *, only unmapped reads are
     * returned.
     * </pre>
     *
     * <code>string reference_name = 3;</code>
     */
    public function getReferenceName()
    {
        return $this->reference_name;
    }

    /**
     * <pre>
     * The reference sequence name, for example `chr1`,
     * `1`, or `chrX`. If set to *, only unmapped reads are
     * returned.
     * </pre>
     *
     * <code>string reference_name = 3;</code>
     */
    public function setReferenceName($var)
    {
        GPBUtil::checkString($var, True);
        $this->reference_name = $var;
    }

    /**
     * <pre>
     * The start position of the range on the reference, 0-based inclusive. If
     * specified, `referenceName` must also be specified.
     * </pre>
     *
     * <code>int64 start = 4;</code>
     */
    public function getStart()
    {
        return $this->start;
    }

    /**
     * <pre>
     * The start position of the range on the reference, 0-based inclusive. If
     * specified, `referenceName` must also be specified.
     * </pre>
     *
     * <code>int64 start = 4;</code>
     */
    public function setStart($var)
    {
        GPBUtil::checkInt64($var);
        $this->start = $var;
    }

    /**
     * <pre>
     * The end position of the range on the reference, 0-based exclusive. If
     * specified, `referenceName` must also be specified.
     * </pre>
     *
     * <code>int64 end = 5;</code>
     */
    public function getEnd()
    {
        return $this->end;
    }

    /**
     * <pre>
     * The end position of the range on the reference, 0-based exclusive. If
     * specified, `referenceName` must also be specified.
     * </pre>
     *
     * <code>int64 end = 5;</code>
     */
    public function setEnd($var)
    {
        GPBUtil::checkInt64($var);
        $this->end = $var;
    }

    /**
     * <pre>
     * Restricts results to a shard containing approximately `1/totalShards`
     * of the normal response payload for this query. Results from a sharded
     * request are disjoint from those returned by all queries which differ only
     * in their shard parameter. A shard may yield 0 results; this is especially
     * likely for large values of `totalShards`.
     * Valid values are `[0, totalShards)`.
     * </pre>
     *
     * <code>int32 shard = 6;</code>
     */
    public function getShard()
    {
        return $this->shard;
    }

    /**
     * <pre>
     * Restricts results to a shard containing approximately `1/totalShards`
     * of the normal response payload for this query. Results from a sharded
     * request are disjoint from those returned by all queries which differ only
     * in their shard parameter. A shard may yield 0 results; this is especially
     * likely for large values of `totalShards`.
     * Valid values are `[0, totalShards)`.
     * </pre>
     *
     * <code>int32 shard = 6;</code>
     */
    public function setShard($var)
    {
        GPBUtil::checkInt32($var);
        $this->shard = $var;
    }

    /**
     * <pre>
     * Specifying `totalShards` causes a disjoint subset of the normal response
     * payload to be returned for each query with a unique `shard` parameter
     * specified. A best effort is made to yield equally sized shards. Sharding
     * can be used to distribute processing amongst workers, where each worker is
     * assigned a unique `shard` number and all workers specify the same
     * `totalShards` number. The union of reads returned for all sharded queries
     * `[0, totalShards)` is equal to those returned by a single unsharded query.
     * Queries for different values of `totalShards` with common divisors will
     * share shard boundaries. For example, streaming `shard` 2 of 5
     * `totalShards` yields the same results as streaming `shard`s 4 and 5 of 10
     * `totalShards`. This property can be leveraged for adaptive retries.
     * </pre>
     *
     * <code>int32 total_shards = 7;</code>
     */
    public function getTotalShards()
    {
        return $this->total_shards;
    }

    /**
     * <pre>
     * Specifying `totalShards` causes a disjoint subset of the normal response
     * payload to be returned for each query with a unique `shard` parameter
     * specified. A best effort is made to yield equally sized shards. Sharding
     * can be used to distribute processing amongst workers, where each worker is
     * assigned a unique `shard` number and all workers specify the same
     * `totalShards` number. The union of reads returned for all sharded queries
     * `[0, totalShards)` is equal to those returned by a single unsharded query.
     * Queries for different values of `totalShards` with common divisors will
     * share shard boundaries. For example, streaming `shard` 2 of 5
     * `totalShards` yields the same results as streaming `shard`s 4 and 5 of 10
     * `totalShards`. This property can be leveraged for adaptive retries.
     * </pre>
     *
     * <code>int32 total_shards = 7;</code>
     */
    public function setTotalShards($var)
    {
        GPBUtil::checkInt32($var);
        $this->total_shards = $var;
    }

}

